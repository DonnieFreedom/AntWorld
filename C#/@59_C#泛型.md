# C#泛型

[Microsoft C# 编码约定](https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/coding-style/coding-conventions)

[Microsoft C# 参考](https://learn.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2012/618ayhy6(v=vs.110))

[Microsoft C#文档](https://learn.microsoft.com/zh-cn/dotnet/csharp/)

在 C# 中，泛型（Generic）是一种规范, 它允许我们使用占位符来定义类和方法，编译器会在编译时将这些占位符替换为指定的类型，利用泛型的这一特性我们可以定义通用类（泛型类）或方法（泛型方法）。

定义通用类需要使用尖括号`<>`，这里的尖括号用于将类或方法声明为泛型。

```C#
using System;
using System.Collections;
namespace c.sharp
{
    // 定义泛型类
    class GenericClass<T>{
        // 泛型方法
        public GenericClass(T msg){
            Console.WriteLine(msg);
        }
    }
    class Demo
    {
        static void Main(string[] args){
            GenericClass<string> str_gen = new GenericClass<string>("C语言中文网");
            GenericClass<int> int_gen = new GenericClass<int>(1234567);
            GenericClass<char> char_gen = new GenericClass<char>('C');
            Console.ReadKey();
        }
    }
}

/*
C语言中文网
1234567
C
*/
```



- ### 泛型的特性

- ### 泛型方法

- ### 泛型委托


> 

#### 泛型的特性

泛型类和泛型方法兼具可重用性、类型安全性和效率，这是非泛型类和非泛型方法无法实现的。

泛型通常与集合以及作用于集合的方法一起使用，System.Collections.Generic 命名空间下就包含几个基于泛型的集合类。

- 使用泛型类型可以最大限度地重用代码、保护类型的安全性以及提高性能；
- 泛型最常见的用途是创建集合类；
- .NET 类库在 System.Collections.Generic 命名空间中包含几个新的泛型集合类，您可以使用这些类来代替 System.Collections 中的集合类；
- 您可以创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托；
- 您也可以对泛型类进行约束以访问特定数据类型的方法；
- 在泛型数据类型中所用类型的信息可在运行时通过使用反射来获取。



#### 泛型方法

可以通过类型参数声明泛型方法。

```C#
using System;
using System.Collections.Generic;

namespace c.sharp
{
    class Demo
    {
        static void Swap<T>(ref T lhs, ref T rhs)
        {
            T temp;
            temp = lhs;
            lhs = rhs;
            rhs = temp;
        }
        static void Main(string[] args)
        {
            int a, b;
            char c, d;
            a = 10;
            b = 20;
            c = 'I';
            d = 'V';
            // 在交换之前显示值
            Console.WriteLine("调用 swap 之前的 Int 值:");
            Console.WriteLine("a = {0}, b = {1}", a, b);
            Console.WriteLine("调用 swap 之前的字符值:");
            Console.WriteLine("c = {0}, d = {1}", c, d);
            // 调用 swap
            Swap<int>(ref a, ref b);
            Swap<char>(ref c, ref d);
            // 在交换之后显示值
            Console.WriteLine("调用 swap 之后的 Int 值:");
            Console.WriteLine("a = {0}, b = {1}", a, b);
            Console.WriteLine("调用 swap 之后的字符值:");
            Console.WriteLine("c = {0}, d = {1}", c, d);
            Console.ReadKey();
        }
    }
}

/*
调用 swap 之前的 Int 值:
a = 10, b = 20
调用 swap 之前的字符值:
c = I, d = V
调用 swap 之后的 Int 值:
a = 20, b = 10
调用 swap 之后的字符值:
c = V, d = I
*/
```



#### 泛型委托

使用类型参数定义泛型委托，如下例所示:

```
delegate T NumberChanger<T>(T n);
```

```C#
using System;
using System.Collections.Generic;
namespace c.sharp
{
    class Demo
    {
        delegate T NumberChanger<T>(T n);
        static int num = 10;
        public static int AddNum(int p){
            num += p;
            return num;
        }
        public static int MultNum(int q){
            num *= q;
            return num;
        }
        public static int getNum(){
            return num;
        }
        static void Main(string[] args){
            // 创建委托实例
            NumberChanger<int> nc1 = new NumberChanger<int>(AddNum);
            NumberChanger<int> nc2 = new NumberChanger<int>(MultNum);
            // 使用委托对象调用方法
            nc1(25);
            Console.WriteLine("Num 的值为: {0}", getNum());
            nc2(5);
            Console.WriteLine("Num 的值为: {0}", getNum());
            Console.ReadKey();
        }
    }
}
/*
Num 的值为: 35
Num 的值为: 175
*/
```



